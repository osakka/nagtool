#!/usr/bin/perl -wT
# The Nagios Tool.
# by Omar Al-Sakka
###############################################################################

use strict;
no strict 'refs';
#use diagnostics;
use Getopt::Std;
#use Data::Dumper;

### Some Globals.
###############################################################################
my $NAGCFG_CONFIGURATION = "/opt/nagtool/etc/tool.cfg"; # Main Config.
my $sf="/var/spool/nagios/nagios.log";                    # Status File.
my %dh;                                                       # Data Hash.
my %sh;                                                       # Status Hash.
my @devlist;                                                  # Device List.
my $ver="0.4p";                                               # Version.
my ($uid, $gid);                                              # User/Group ID.
my $llu;                                                      # Last $lu.
my $wbell=0;                                                  # Warning Bell.
my $ring;                                                     # Ringer?
my $xtndd=0;                                                  # Extended Info.

### Set Some Colours.
###############################################################################
my $warning = "\e[0;33m";
my $critical = "\e[0;31m";
my $title = "\e[7;39m";
my $down = "\e[7;31m";
my $rst = "\e[1;1H";
my $black = "\e[0;39m";
my $bell = "\007";
my $clr = "\e[02J$black$rst";

### Panic, and report error.
###############################################################################
sub panic {
  if ("@_" eq "") { print qq|$0: $!\n|; }
  else { print qq|$0: @_\n|; }
  exit(1);
}

### Make a Warning Banner at top of File.
###############################################################################
sub make_warning {
  return "#" x 80 . "\n"
       . "# PLEASE DO NOT EDIT THIS FILE BY HAND, IT HAS BEEN "
       . "GENERATED\n# by $0 v$ver.\n"
       . "# The Configs can be found in $dh{G}{G}{basedir}\n"
       . "#" x 80 . "\n\n";
}

### Draw a Line.
###############################################################################
sub ln { print "#" x 80 . "\n"; }

### Load Main Configuration.
###############################################################################
sub load_config {
  if ( open(CFG, "$NAGCFG_CONFIGURATION") ) {
    while (<CFG>) {
      chomp ($_);       # ensure no return.
      s/\t/ /g;         # Replace tabs by space.
      s/\s/ /g;         # Replace Whitespaces with space.
      s/\s+$//g;        # Remove WhiteSpaces at endof-line.
      next if /^\s*\#/; # Ignore a Comment.
      next if /^\s*$/;  # Ignore empty line.
      next if /^\s+$/;  # ignore white space.
      # Configuration Defaults.
      if (/^([A-Z_a-z]+)\s+([A-Z_a-z]+)\s+(.*)$/) {
        $dh{G}{lc($1)}{lc($2)} = "$3";
        next;
      }
      # Load Multiple Entry Config Files.
      if (/^([A-Z_a-z]+)\[(\d+)\]\s+(.*)$/) {
        $dh{G}{G}{lc($1)}{$2} = "$3";
        next;
      }
      # Load in Default Configs.
      if (/^([A-Z_a-z]+)\s+(.*)$/) {
        $dh{G}{G}{lc($1)} = "$2";
        next;
      }
      panic ("syntax error in line $. of configuration file.");
    }
    close (CFG);
  } else { panic ("configuration file not found!"); }
}

### Slurp in Status File.
###############################################################################
sub get_status {
  if (open (STATUS, "$sf") ) {
    while (<STATUS>) {
      chomp($_);
      s/\t/ /g;         # Replace tabs by space.
      s/\s/ /g;         # Replace Whitespaces with space.
      s/\s+$//g;        # Remove WhiteSpaces at endof-line.
      next if /^\s*\#/; # Ignore a Comment.
      next if /^\s*$/;  # Ignore empty line.
      next if /^\s+$/;  # ignore white space.
      if ( /^\[(\d+)\]\W+(.*)$/ ) {
        (my @t) = split(/;/, "$2");
        if ( $t[0] eq "HOST" ) { $sh{$t[1]}{'*'}{'*'} = lc($t[2]); }
        elsif ( $t[0] eq "SERVICE" ) { 
          $sh{$t[1]}{$t[2]}{S} = lc($t[3]);  # State.
          # Number of Retries.
          if (defined($t[4])) { $sh{$t[1]}{$t[2]}{T} = "$t[4]"; }  
          else { $sh{$t[1]}{$t[2]}{T} = "--"; }
        }
        next;
      }
      else { panic ("error in status log line $."); }
    }
    close (STATUS);
  } else { panic ("cannot open nagios status file."); }
}

### Make Padding.
###############################################################################
sub justify {
  my ($in, $j) = @_ or panic ("var name and justification needed.");
  if (length($in) > $j) { $in = substr($in, 0, ( $j - 3 )) . " >>"; }
  return $in . ' ' x ( $j - length($in) );
}

### Print out Entries.
###############################################################################
sub console {
  my $show; # Show Service?
  my $line; # Line to Output.
  my $lu;   # Last Update.
  my $ct;   # Current Time.
  my $fl;   # Flag.

  # Get Status File, and Set Times.
  get_status;
  $lu = scalar localtime ((stat($sf))[9]);
  $ct = scalar localtime(time);

  # Do not Refresh if $llu eq $lu, just update time.
  if ($lu eq $llu) { 
    print "$rst" . &justify("NagTool Console v$ver", 56) . "$ct$rst";
    print "$bell" if (($ring) and ($wbell));
    return;
  }

  # Header.
  $ring=0; # Reset Ringer.
  print "$clr";
  print &justify("NagTool Console v$ver", 56) . "$ct\n"
      . "Nagios Command Line Status Viewer."
      . &justify("",26) . "press CTRL-c to exit\n"
      . "Status last updated at $lu \n"
      . "Legend : "
      . "Yellow - Warning, Red - Critical, Red Line - Host Down.\n"
      . "         service_name(^) - Flagged Service is Critical.\n"
      . "$title"
      . &justify(" HOST NAME", 18);
  if ($xtndd) {
    print "  " . &justify("GROUP", 14)
        . &justify("IP ADDRESS", 14)
        . &justify("[ RETRY STATUS ] >>", 32);
  }
  else { print &justify("[ RETRY STATUS ] >>", 62); }
  print "$black\n";

  # Body.
  foreach my $x (keys(%sh)) {
    next if ($x eq "*");   # Signify Global Vars.
    $show=0;  # Reset Output on!
    $line=""; # Reset the Output Line.
    $line .= &justify(" $x",20);
    if ($xtndd) {
      $line .= &justify("$dh{$x}{group}",14);
      $line .= &justify("$dh{$x}{ip}",16);
    }
    # Host is Down.
    if ($sh{$x}{'*'}{'*'} eq "down") {
      $line .= "Host is Down!";
      print "$down" . &justify($line,80) . "$black\n";
      $ring = 1;
      next;
    }
    foreach my $y (sort keys %{$sh{$x}}) {
      $fl = ""; # Reset Flag.
      next if ($y eq "*"); # Signify Host Status.
      next if ($sh{$x}{$y}{S} eq "ok");
      if ($sh{$x}{$y}{S} eq "warning") { 
        $show = 1 unless ($show == 2);
      }
      if ($sh{$x}{$y}{S} eq "critical") { 
        $show = 2;
        print "$bell" if ($wbell); # Ring the Bell.
        $fl = "^";
      }
      $line .= &justify("\[$sh{$x}{$y}{T}\]", 6);
      $line .= &justify("$y$fl",7);
    }
    print "$warning" if ($show == 1);
    if ($show == 2) { 
      print "$critical"; 
      print "$bell" if ($wbell); # Ring the Bell.
    }
    print &justify($line,80) . "$black\n" if ($show);
  }
  $llu="$lu";
  print "$rst";
}

### Generate Hosts File.
###############################################################################
sub make_hosts {
  my @services;

  if ( open(CFG, ">>$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{config}") ) {
    select (CFG);
    print &make_warning;
    foreach my $dev (sort keys(%dh)) {
      next if ( $dev eq "G" );
      next if (!$dh{$dev}{status});
      print "# Host $dev Definition.\n";
      &ln;
      print "define host {\n"
          . "  host_name           $dev\n"
          . "  alias               $dh{$dev}{descr}\n"
          . "  address             $dh{$dev}{ip}\n"
          . "  use                 Generic Host Template.\n"
          . "}\n";
      print "\n";
      (@services) = split(/,/, "$dh{$dev}{services}");
      foreach ( @services ) {
        print "# Service $dh{$dev}{services} Definition.\n";
        &ln;
        print "define service {\n"
            . "  host_name           $dev\n"
            . "  service_description $_\n"
            . "  use                 $_\n"
            . "  register            1\n"
            . "  contact_groups      $dh{$dev}{contacts}\n"
            . "}\n";
        print "\n";
      }
    }
    select(STDOUT);
    close (CFG);
    chown $uid, $gid, "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{config}";
  } else { panic ("cannot append to config '$dh{G}{G}{config}'."); }
}

### Generate Host Groups.
###############################################################################
sub make_groups {
  my $devs = join (", ", @devlist);

  if ( open(CFG, ">>$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{config}") ) {
    select (CFG);
    print "# Group Definition.\n";
    &ln;
    print "define hostgroup {\n"
        . "  hostgroup_name         servers\n"
        . "  alias                  Servers\n"
        . "  name                   Servers\n"
        . "  contact_groups         admins\n"
        . "  members                $devs\n"
        . "}\n\n";
    select(STDOUT);
    close (CFG);
    chown $uid, $gid, "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{config}";
  } else { panic ("cannot append to config '$dh{G}{G}{config}'."); }
}

### Generate Escalation.
###############################################################################
sub make_escalation {
  my $devs = join (", ", @devlist);

  if ( open(CFG, ">>$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{config}") ) {
    select (CFG);
    print "# Service Escalation.\n";
    &ln;
    print "define serviceescalation {\n"
        . "  service_description    *\n"
        . "  hostgroup_name         servers\n"
        . "  contact_groups         admins\n"
        . "  host_name              $devs\n"
        . "}\n\n";
    select(STDOUT);
    close (CFG);
    chown $uid, $gid, "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{config}";
  } else { panic ("cannot append to config '$dh{G}{G}{config}'."); }
}

### Substitute Default Values.
###############################################################################
sub substitute_defaults {
  my $name = $_[0] or panic ("substitution name undefined");

  $dh{$name}{ip} = $dh{G}{host}{ip} if ($dh{$name}{ip} eq "");
  $dh{$name}{group} = $dh{G}{host}{group} if ($dh{$name}{group} eq "");
  $dh{$name}{descr} = $dh{G}{host}{descr} if ($dh{$name}{descr} eq "");
  $dh{$name}{contacts} = $dh{G}{host}{contacts} if ($dh{$name}{contacts} eq "");
  $dh{$name}{services} = $dh{G}{host}{services} if ($dh{$name}{services} eq "");
}

### Load Host Database.
###############################################################################
sub load_database {
  if ( open(DBASE, "$dh{G}{G}{basedir}/$dh{G}{G}{hostdbase}") ) {
    while (<DBASE>) {
      chomp ($_);       # ensure no return.
      s/\t/ /g;         # Replace tabs by space.
      s/\s/ /g;         # Replace Whitespaces with space.
      s/\s+$//g;        # Remove WhiteSpaces at endof-line.
      next if /^\s*\#/; # Ignore a Comment.
      next if /^\s*$/;  # Ignore empty line.
      next if /^\s+$/;  # ignore white space.
      # Load in Machine Details.
      # Name:Status:Group:IP:Contacts:Description:Services
      if (/^([A-Z_a-z0-9]+):(\d):(.*):(.*):(.*):(.*):(.*)$/) {
        $dh{$1}{status}   = $2;
        $dh{$1}{group}    = $3;
        $dh{$1}{ip}       = $4;
        $dh{$1}{contacts} = $5;
        $dh{$1}{descr}    = $6;
        $dh{$1}{services} = $7;
        &substitute_defaults("$1");
        # Add to The Device Array.
        push (@devlist, $1) unless (!$dh{$1}{status});
        next;
      }
      panic ("syntax error in line $. of database file.");
    }
    close (DBASE);
  } else { panic ("host database not found!"); }
}

### Redump Host Database.
###############################################################################
sub dump_hostdb {
  my $hdb=""; 

  # Make Host Entries.
  foreach my $i (sort keys (%dh)) {
    next if ($i eq "G"); # Skip Global Config.
    $hdb .= qq|$i:$dh{$i}{status}:$dh{$i}{group}:$dh{$i}{ip}:|
          . qq|$dh{$i}{contacts}:$dh{$i}{descr}:$dh{$i}{services}\n|;
  }
  return $hdb;
}

## Remove Old Files.
###############################################################################
sub delete_old {
  foreach my $o ( keys %{$dh{G}{G}} ) {
    foreach my $n ( keys %{$dh{G}{G}{$o}} ) {
      if ( -e "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{$o}" ) {
        unlink ("$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{$o}");
      }
    }
  }
  # Remove Validator File.
  if ( -e "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{validator}" ) {
    unlink ("$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{validator}");
  }
}

### Concat Templates.
###############################################################################
sub make_std {
  my $sw; # One Time Switch.

  # Start the Generation.
  foreach my $o ( keys %{$dh{G}{G}} ) {
    $sw = 0;
    foreach my $n ( keys %{$dh{G}{G}{$o}} ) {
      # Open Configuration File.
      if ( open(CFG, ">>$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{$o}") ) {
        print CFG &make_warning if (!$sw);
        if ( open(DATA, "$dh{G}{G}{basedir}/$dh{G}{G}{$o}{$n}") ) {
          while (<DATA>) { print CFG; }
          close (DATA);
        } else { panic ("cannot open template file '$dh{G}{G}{$o}{$n}'."); }
        close(CFG);
        chown $uid, $gid, "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{$o}";
      } else { panic ("cannot create config file '$dh{G}{G}{$o}'."); }
      $sw=1;
    } 
  }
}

### Check User.
###############################################################################
sub verify_user {
  my ($login,$pass,$id,$ugid) = getpwnam($dh{G}{G}{user})
    or panic ("$dh{G}{G}{user} not in passwd file");
  $uid = $id;
  $gid = getgrnam($dh{G}{G}{group})
    or panic ("$dh{G}{G}{group} not in passwd file");
}

### Verify Configuration and Report.
###############################################################################
sub verify_cfg {
  my $nagios_config = "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{nagioscfg}";
  my $validator = "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{validator}";

  if ( -x "$dh{G}{G}{nagiosbin}" ) {
    `$dh{G}{G}{nagiosbin} -v $nagios_config && echo >$validator`;
  } else { panic ("cannot invoke nagios executable."); }
  if ( -e "$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{validator}" ) {
    # Remove Validator File.
    unlink ("$dh{G}{G}{nagioscfgdir}/$dh{G}{G}{validator}");
    panic ("Configuration built ok!");
  } 
  else { panic ("Configuration Error!\n"
              . "$0: $dh{G}{G}{nagiosbin} "
              . "-v $nagios_config to verify."); 
  }
}

### Require Lock and unlock Functions.
###############################################################################

### Host Add and Delete.
###############################################################################
sub host {
  my ($action, $name) = @_ or panic ("host call requires action and name.");
  
  ### Disable a host.
  if ($action eq "enable") {
    if (defined($dh{$name})) { 
      if (!$dh{$name}{status}) { $dh{$name}{status}=1; }
      else { panic ("host already enabled."); }
    } else { panic ("host does not exist."); }
  }
  ### Disable a Host.
  if ($action eq "disable") {
    if (defined($dh{$name})) {
      if ($dh{$name}{status}) { $dh{$name}{status}=0; }
      else { panic ("host already disabled."); }
    } else { panic ("host does not exist."); }
  }
  ### Write Out the New Config File.
  if ( open(HOSTDB, ">$dh{G}{G}{basedir}/hostdb_$$") ) {
    print HOSTDB &make_warning;
    print HOSTDB &dump_hostdb;
    close (HOSTDB);
  }
  else { panic ("cannot create database file 'hostdb_$$'"); }
  ### Cleanup.
  rename "$dh{G}{G}{basedir}/$dh{G}{G}{hostdbase}", 
    "$dh{G}{G}{basedir}/$dh{G}{G}{hostdbase}.bak";
  rename "$dh{G}{G}{basedir}/hostdb_$$", 
    "$dh{G}{G}{basedir}/$dh{G}{G}{hostdbase}";
}

### List IP Addresses.
### Regex on Input.
###############################################################################
sub ip_list {
  my $i;
  my $t;
  my $loop=0;

  panic ("invalid serarch criteria.") if ($_[0] !~ m/[0-9\.\^\*\$]+/);

  &ln;
  print qq|  IP Address       HostName            |;
  print qq|Status     Description\n|;
  &ln;

# Declare Format for Output.
format STDOUT =
  @<<<<<<<<<<<<< | @<<<<<<<<<<<<<<<< | @<<<<<<< | @<<<<<<<<<<<<<<<<<<<<<<<<<<
  $dh{$i}{ip}, $i, $t, $dh{$i}{descr}
.

  foreach $i (sort keys (%dh)) {
    next if ($i eq "G");
    next if ($dh{$i}{ip} !~ /$_[0]/);
    $loop++;
    next if ($i eq "G"); # Skip Global Config.
    if ($dh{$i}{status} == 0) { $t="disabled"; }
    else { $t="active"; }
    write();
  }
  print qq|  No Results Found.\n| if (!$loop);
  &ln;
}

### List IP Ranges.
###############################################################################
sub list_ranges {

}

### Build Nagios Config Files.
###############################################################################
sub build_config {
  &verify_user;
  &delete_old;
  &make_hosts;
  &make_groups;
  &make_escalation;
  &make_std;
  &verify_cfg;
}

### Help.
###############################################################################
sub help {
  print STDERR << "EOHelp";
NagTool v$ver Quick Help.

  usage: $0 [-cbBrxv] [-adefl <option(s)>]

  -c    Nagios Console.
        THIS REQUIRES 80 COLUMNS.
  -x    Show Extended information in Console.
  -B    Switch Bell On for Critical Problems.
  -b    Build Nagios Configuration Files.
  -r    List IP Ranges Specified.
  -l    List IP Addresses in Host Database.
        A Regular Expression Has to be Specified.
        class = [0-9\\\.\\\^\\\*\\\$]+
        eg .* for all!
  -a    Allocate an IP address in the Range.
  -f    Free an allocated IP address.
  -e    Change host status to enabled.
  -d    Change host status to disabled.
  -v    Report Version Number.

EOHelp
  exit(1);
}

### Command Line Menu.
###############################################################################
sub cl_menu {
  my $options = 'Bxvcbra:d:e:f:l:';
  my $s=0;  # Success!

  getopts("$options", \my %opt) or &help;
   if ($opt{B}) { $wbell=1; }
   if ($opt{x}) { $xtndd=1; }
   # The Console.
   if ($opt{c}) { 
     # Setup Some Signal Handling.
     $SIG{'WINCH'} = sub { $llu = ""; &console; };
     $SIG{'INT'}  = sub { print "$clr"; exit; };
     for (;;) { &console; sleep 1; } 
     exit;
   }
   if ($opt{b}) { $s=1; &build_config; }
   if ($opt{r}) { $s=1; &list_ranges; }
   if ($opt{l}) { $s=1; &ip_list($opt{l}); }
   if ($opt{a}) { $s=1; &host("allocate", "$opt{a}"); }
   if ($opt{f}) { $s=1; &host("free", "$opt{f}"); }
   if ($opt{e}) { $s=1; &host("enable", "$opt{e}"); }
   if ($opt{d}) { $s=1; &host("disable", "$opt{d}"); }
   if ($opt{v}) { $s=1; print "NagTool v$ver\n"; }
  &help if ($s==0); # Nothing Specified!
}

### Start Everything Here.
###############################################################################
MAIN: {
  delete @ENV{'IFS', 'CDPATH', 'PATH', 'ENV', 'BASH_ENV'};
  $|++;           # Force Auto-Flush of Output Buffer.
  &load_config;   # Load IPdB Configuration.
  &load_database; # Load NagCfg Database File.
  &cl_menu;       # CL Menu (getopt).
}
